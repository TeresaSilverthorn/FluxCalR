#' @title
#'
#' @description
#'
#' @param
#'
#' @return
#'
#' @examples
#'
#' @export

##############################################

## Function for loading data from LGR ----------
Load_LGR <- function(file, ## set "file" as raw data file name (as string) WITHOUT changing anything
                     Time_format="mdy_hms" ## depending on the output timestamp, you may change into "dmy_hms" or "ymd_hms"
                    ){
  library(lubridate)
  # Load the raw data after deleting the text massages at the beginning and the end of each raw data file generate by LGR
  flux <- read.table(file, sep= ",", header = T,skip = 1,fill = T,stringsAsFactors = F)
  flux <- subset(flux,!is.na(flux[,2])) # remove the comments generated by LGR
  # replace the time with "lubridated" time with different format
  if (Time_format=="mdy_hms"){
    flux$Time <- mdy_hms(flux$Time)
  } else {
    if (Time_format=="dmy_hms"){
      flux$Time <- dmy_hms(flux$Time)
    } else {
      flux$Time <- ymd_hms(flux$Time) # with Time_format = "ymd_hms"
    }
  }
  return(flux)
}

## Function for loading data from other sources ----------
Load_other <- function(file, ## set "file" as raw data file name (as string) WITHOUT changing anything
                       Time_format="mdy_hms", ## depending on the output timestamp, you may change into "dmy_hms" or "ymd_hms", or if only time is recorded use "hms"
                       Date = "1/31/2018", # add the date of measurement in the format of "mm/dd/yyyy"
                       Time, # header name of the timestamps in the file (string)
                       CO2, # header name of the CO2 concentrations in the file (string)
                       CH4 = NA, # header name of the CH4 concentrations in the file (string). Default: no CH4 is measured
                       Ta = 25, # header name of ambient air temperature in the file (string). If not measured, a constant value can be used. Default: 25 degree C
                       skip = 0, # rows to be skipped at the beginning. Default: no rows will be skipped
                       sep = "," # delimiter to separate columns. Default: comma (",")
                       )
                       {
  library(lubridate)
  # Load the raw data after deleting the text massages at the beginning and the end of each raw data file generate by LGR
  flux <- read.table(file, sep= sep, header = T,skip = skip,fill = T,stringsAsFactors = F)
  flux <- subset(flux,!is.na(flux[,2])) # remove the comments generated by analyzer
  flux <- data.frame()
  # replace the time with "lubridated" time with different format
  if (Time_format=="mdy_hms"){
    flux$Time <- mdy_hms(flux[,Time])
  } else {
      if (Time_format=="dmy_hms"){
      flux$Time <- dmy_hms(flux[,Time])
    } else {
        if (Time_format=="ymd_hms"){
        flux$Time <- ymd_hms(flux[,Time]) # with Time_format = "ymd_hms"
        } else {
          Time <- paste0(Date,"_",flux[,Time]) # if only time is provided, then combine the time with date first
          flux$Time <- mdy_hms(Time)
        }
      }
  }

  flux$X.CO2.d_ppm <- flux[,CO2] # add a column as CO2 concentration with correct name
  # add a column as CH4 concentration
  if (is.na(CH4)){
    flux$X.CH4.d_ppm <- NA # create a column with NAs if CH4 is not measured
  } else {
    flux$X.CH4.d_ppm <- flux[,CH4]
  }
  # add a column as ambient air temperature
  if (is.string(Ta)){
    flux$AmbT_C <- flux[,Ta]
  } else {
    flux$AmbT_C <- Ta
  }

  return(flux)
}

## Flux calculation function starts from here ---------------
FluxCal <- function(data, ## the data loaded by the function "Load_LGR" or "Load_other"
                    t, ## window width for slope calculation, unit: minutes
                    spt=1, ## set"spt", how many groups you would like to split your data into as you selet the peaks and valleys
                    Time_keys = NA, # load a file with times (HH:MM:SS) that separate the flux calculation, with header as either "Start" or "End".
                    # if no file provided, a graph window will pop up to allow manually select the end points
                    Type_keys = "start", # select if "end" time or "start" time will be used to separate the flux; default "start"
                    vol, # volume of the chamber; unit: dm^3 or L
                    Ta = NA, # air temperature; unit: degree C. A file name with a column "Ta" in the file. The length of Ta must be the same as number of measurements
                    # Default: use the average ambient air temperature measured by analyzer
                    Area, # base area of the chamber; unit: m^2
                    output_d = "Flux_output.csv" # the output directory
) {
  # packages
  library(tidyverse)
  library(lubridate)
  library(assertthat)

  # constants
  R_index = 0.08205783 # universal gas constant; unit: L*atm*K^-1*mol^-1
  Mol_CO2 = 44 # molar mass for CO2; unit: g/mol
  Mol_CH4 = 16 # molar mass for CH4; unit: g/mol

  flux <- data

  # creating a index for spiliting the window
  nr <- nrow(flux) # number of rows

  f <- round(as.numeric(flux$Time[2]-flux$Time[1])) # calculate the sampling frequency based on the timestamps.

  # add one column as row index and one as time (HH:MM:SS)
  flux <- cbind(Row=row(flux)[,1],flux) %>%
    mutate(time=paste(hour(Time),sprintf("%02d",minute(Time)),sprintf("%02d",floor(second(Time))),sep = ":"))

  ######## select the points to separate the measurements
  ### 1. if NO Time_keys are provided
  if (is.na(Time_keys)){
    # plot CO2 vs index for locating the peaks and valleys
    In <- c() # create a variable as Index
    for (i in 1:spt){
      x11(16,10)
      with(flux[c(((i-1)*nr/spt)+1):c(i*nr/spt),],
           plot(Time,X.CO2.d_ppm,
                ylab = "CO2 in ppm",
                main = "Click on the peaks and valleys",
                cex.main=2.5, col.main="red",
                ylim = c(360,450), cex = 0.8, xaxt="n"
           ))

      # add time interval ticks
      a <- pretty_dates(flux$Time[c(((i-1)*nr/spt)+1):c(i*nr/spt)],10)
      # which(minute(flux$Time) %in% c(0,15,30,45) & floor(second(flux$Time)) %in% c(0,1))
      axis.POSIXct(1, at= a,format = "%H:%M")
      abline(v=a, lty="dotted",col="grey")
      In_t <- with(flux[c(((i-1)*nr/spt)+1):c(i*nr/spt),],identify(Time,X.CO2.d_ppm))
      In_t <- In_t + ((i-1)*nr/spt)
      In <- c(In,In_t)
      dev.off()
    }
    # plot CH4 vs index for locating the peaks and valleys
    # x11(14,10)
    # with(flux,plot(Row,X.CH4.d_ppm,
    #                ylab = "CH4 in ppm",
    #                main = "CH4",cex.main=3, col.main="blue"#,
    #                # ylim = c(1.7,3)
    #                ))
    # In <- with(flux,identify(Row,X.CH4.d_ppm))
    # dev.off()

    # sort the "In" in ascending order in case of click in the wrong order
    In <- sort(In)
  } else {
    Time_keys <- read.table(Time_keys,sep = ",",header = T)
    ### 2. if Time_keys are provide and the "end" is selected for Type_keys
    if (Type_keys == "end"){
      In <- match(Time_keys$End,flux$time)
    } else {
      ### 3. if Time_keys are provide and the "start" is selected for Type_keys
      In_t <- match(Time_keys$Start,flux$time)
      In <- In_t + 1.2*t*60/f # select the point 1.2 of the window width after the starting point
    }
  }

  # return a error if In includes NAs
  if (anyNA(In)) {
    stop(paste0("Change the timestamp (No.",which(is.na(In)),") in 'Time_keys' 1 second forward"))
  }

  ### calculate the max R2 of the regression before local max and min
  # R2 of CO2 fluxes
  Ta_CO2 <- vector() # for calculating average ambient temperature
  R2.CO2 <- data.frame(matrix(0,length(In),7))
  colnames(R2.CO2) <- c("R2_CO2","Index_CO2","Slope_CO2","p_CO2","Flux","Date","time_CO2")
  for (a in 1:length(In)){
    for (b in In[a]:c(In[a]-0.5*t*60/f)){ # select 0.5 of the window width as testing for largest R2
      Slm <- summary(lm(flux$X.CO2.d_ppm[(b-t*60/f):b]~flux$Row[(b-t*60/f):b]))
      if (Slm$r.squared > R2.CO2[a,1]) {
        R2.CO2[a,1] <- Slm$r.squared
        # output the time at the start of the slope
        R2.CO2[a,2] <- b
        R2.CO2[a,3] <- Slm$coefficients[2]/f
        R2.CO2[a,4] <- Slm$coefficients[8]
        R2.CO2[a,5] <- "CO2"
        R2.CO2[a,6] <- paste0(year(flux$Time[1]),"-",month(flux$Time[1]),"-",day(flux$Time[1]))
        R2.CO2[a,7] <- paste0(hour(flux$Time[(b-t*60/f)]),":",
                              minute(flux$Time[(b-t*60/f)]),":",
                              floor(second(flux$Time[(b-t*60/f)])))
        Ta_CO2[a] <- mean(flux$AmbT_C[(b-t*60/f):b])
      }
    }
  }

  # R2 of CH4 fluxes
  Ta_CH4 <- vector() # for calculating average ambient temperature
  R2.CH4 <- data.frame(matrix(0,length(In),7))
  colnames(R2.CH4) <- c("R2_CH4","Index_CH4","Slope_CH4","p_CH4","Flux","Date","time_CH4")
  for (a in 1:length(In)){
    for (b in In[a]:c(In[a]-0.5*t*60/f)){
      Slm <- summary(lm(flux$X.CH4.d_ppm[(b-t*60/f):b]~flux$Row[(b-t*60/f):b]))
      if (Slm$r.squared > R2.CH4[a,1]) {
        R2.CH4[a,1] <- Slm$r.squared
        R2.CH4[a,2] <- b
        R2.CH4[a,3] <- Slm$coefficients[2]/f
        R2.CH4[a,4] <- Slm$coefficients[8]
        R2.CH4[a,5] <- "CH4"
        R2.CH4[a,6] <- paste0(year(flux$Time[1]),"-",month(flux$Time[1]),"-",day(flux$Time[1]))
        R2.CH4[a,7] <- paste0(hour(flux$Time[(b-t*60/f)]),":",
                              minute(flux$Time[(b-t*60/f)]),":",
                              floor(second(flux$Time[(b-t*60/f)])))
        Ta_CH4[a] <- mean(flux$AmbT_C[(b-t*60/f):b])
      }
    }
  }

  # determine which temperature will be used for flux calculation
  if (is.string(Ta)){
    Tk_CO2 <- read.table(Ta,sep = ",",header = T)$Ta+273.2
    Tk_CH4 <- read.table(Ta,sep = ",",header = T)$Ta+273.2
  } else {
    Tk_CO2 <- Ta_CO2+273.2
    Tk_CH4 <- Ta_CH4+273.2
  }

  # create a index for each slope and calculate the flux
  # CO2
  R2.CO2 <- data.frame(R2.CO2,Id.slope=row(R2.CO2)[,1]) %>%
    mutate(FCO2=((Slope_CO2*vol)/(R_index*Tk_CO2)/Area)) # umol CO2 m-2 s-1
  # CH4
  R2.CH4 <- data.frame(R2.CH4,Id.slope=row(R2.CH4)[,1]) %>%
    mutate(FCH4=((Slope_CH4*vol)/(R_index*Tk_CH4)/Area)) # umol CH4 m-2 s-1

  # Plot the regressions for visualization purpose
  x11(14,10)
  par(mfrow=c(2,1),mar=c(0.5,1,0.5,1),xpd=NA,oma=c(4,4,1,1))
  with(flux,plot(X.CO2.d_ppm,
                 ylab="CO2 readings in ppm", xlab = "",
                 bty="n", xaxt="n"#,ylim=c(380,460)
  ))

  # CO2 regression lines
  for (i in 1:nrow(R2.CO2)){
    Slm <- lm(flux$X.CO2.d_ppm[(R2.CO2[i,2]-t*60/f):R2.CO2[i,2]]~
                flux$Row[(R2.CO2[i,2]-t*60/f):R2.CO2[i,2]])
    lines(flux$Row[(R2.CO2[i,2]-t*60/f):R2.CO2[i,2]], Slm$fitted.values,
          col="green", lwd=3)
    text(flux$Row[In[i]-t*60/f],flux$X.CO2.d_ppm[In[i]-t*60/f],
         labels = paste(R2.CO2[i,8]), # bquote(bold(atop(paste(R^2,"=",.(round(R2.CO2[i,1],2))),
         # paste("b=",.(round(R2.CO2[i,3],2)))))),
         col = "red",cex = 1.2,pos = 3)
  }


  # CH4 flux regression lines in seperate plot
  with(flux,plot(X.CH4.d_ppm, ylab="CH4 readings in ppm", xlab="Time",bty="n", xaxt="n"#, ylim=c(1.7,3)
  ))

  for (i in 1:nrow(R2.CH4)){
    Slm <- lm(flux$X.CH4.d_ppm[(R2.CH4[i,2]-t*60/f):R2.CH4[i,2]]~
                flux$Row[(R2.CH4[i,2]-t*60/f):R2.CH4[i,2]])
    lines(flux$Row[(R2.CH4[i,2]-t*60/f):R2.CH4[i,2]], Slm$fitted.values,
          col="green", lwd=3)
    text(flux$Row[In[i]-t*60/f],flux$X.CH4.d_ppm[In[i]-t*60/f],
         labels = paste(R2.CH4[i,8]), # bquote(bold(atop(paste(R^2,"=",.(round(R2.CH4[i,1],2))),
         # paste("b=",.(round(R2.CH4[i,3]*1000,2)),"e-3")))),
         col="red",cex=1.2,pos = 3)
  }
  par(new=T)
  with(flux,plot(Time,X.CH4.d_ppm,type = "n",axes = F, xlab = "", ylab = ""))
  # add time interval ticks
  c <- pretty_dates(flux$Time,n=10)
  axis.POSIXct(1, at= c,format = "%H:%M")

  # output of the function
  output <- cbind(R2.CO2[,c(6,2,7,3,9,1)],
                  Ta_CO2 = Tk_CO2-273.2,
                  R2.CH4[,c(2,7,3,9,1)],
                  Ta_CH4 = Tk_CH4-273.2)
  write.csv(output,file = output_d,row.names = F)
  return(output)
}
## function end here#####
