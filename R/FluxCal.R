#' @title Calculate CO2 and CH4 gas fluxes
#'
#' @description A function to calculate CO2 and CH4 gas fluxes from the data loaded by the function `LoadLGR()` or `Load_other()`.
#' It takes a time cue data frame (argument `df_cue`), either created by the function `SelCue()` or prepared by the user following the format of
#' "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata, to separate the
#' measurements and calculate the fluxes for all measurements at once.
#' Note that the header for the time cue column must be either *"Start"* or *"End"*.
#' Based on the time cues and window width provided for the calculation, the function will automatically scan over data that cover
#'  1.5x (default) length of the window and calculate the fluxes based on the best linear regression (i.e., largest R2).
#'  After the calculations are done, a graph with regression lines plotted on the CO2 and/or CH4 concentration time series can be
#'  drawn for checkup purposes.
#'
#' @param data A dataframe generated by the function `LoadLGR` or `LoadOther`.
#' @param cal A string, either "CO2_CH4" (default),"CO2" or "CH4", indicates which gas flux it is calculated for.
#' @param win A number indicates the window width for the flux calculation, unit: minutes.
#' @param vol A number indicates volume of the chamber; unit: dm^3 or L.
#' @param area A number indicates base area of the chamber; unit: m^2.
#' @param df_cue A data frame that includes "Start" and/or "End" time (HH:MM:SS) of each measurement.
#' The header for the time must be *"Start"* or *"End"*. This data frame can either be created by the function `SelCue()`
#' or be prepared by the user
#' (see example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata).
#' @param cue_type A string, either "Start", "End" (default) or "Start_End", indicates if start, end or both time in the
#' data frame assigned to `df_cue` will be used as the cues . When "Start_End" is chosen, both "Start" and "End" columns have to
#' be present in the data frame for `df_cue` and the flux with the largest R2 within the range will be calculated without
#' considering the argument `ext`.
#' @param other A vector of strings indicates the names of other columns in the data frame for the `df_cue` argument
#' that need to be passed along to the final output data frame. Default: NULL.
#' @param df_Ta A data frame contains a column "Ta" with the air temperature values (ideally, this is temperature measured inside
#'  of the chamber during the flux measurement; unit: degree C. This can be the same data frame as in `df_cue`.
#'  See example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata). The length of Ta within the file must be the same as the number of flux measurements.
#' Default: NULL, then the temperature used is either the average ambient air temperature measured by the LGR analyzer
#' (column "AmbT_C") or, if the data measured by other analyzers, Ta input from function `LoadOther()`.
#' @param ext A number indicates a range of how many times of the window width (`win`) should the calculation scan through to
#' choose the regression with the largest R2. Default: 1.5. This argument is ignored when `cue_type` is "Start_End".
#' @param output A string includes output directory and file name (.csv) to export the calculated fluxes.
#' Default: a file named "Flux_output.csv" with calculated fluxes will be created under the current work directory.
#' FALSE, do not create a file.
#' @param digits An integer indicates the number of decimal digits to be used for the calculated fluxes and slopes.
#' @param check_plot A logic value indicates whether a checking plot should be drawn after the calculation. Default: TRUE.
#' @param ylim_CO2 A numeric vector of length 2, giving the y-axis scale range for CO2 concentration (ppm) for `check_plot`.
#' If not specified (default), it will be set based on the CO2 range of the entire dataset.
#' @param ylim_CH4 A numeric vector of length 2, giving the y-axis scale range for CH4 concentration (ppm) for `check_plot`.
#' If not specified (default), it will be set based on the CH4 range of the entire dataset.
#'
#' @return A dataframe with calculated CO2 and CH4 fluxes ("FCO2" and "FCH4", respectively; unit: umol m^-2 s^-1) and other parameters (i.e. date, time, index, regression slopes, R2 and Ta). A copy of the dataframe will be saved as "Flux_output.csv" under the work directory or as what is provided in the argument "output_d". A graph with regression lines plotted on the CO2 and/or CH4 concentration time series will pop up for checkup purposes.
#'
#' @examples
#' #### data from LGR
#' # get the directory of the example LGR raw data
#' example_data1 <- system.file("extdata", "Flux_example_1_LGR.txt", package = "FluxCalR")
#' example_data1
#'
#' # load the data
#' Flux_lgr <- Load_LGR(example_data1)
#'
#' # manually select time cues and calculate the fluxes over a 3-minute window
#' Flux_output1 <- FluxCal(data = Flux_lgr, t = 3, vol = 208, Area = 0.26)
#' Flux_output1
#'
#' # input the time cues as a file and calculate the fluxes over a 3-minute window
#' Time_Ta1 <- system.file("extdata", "Time & Ta_1.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Flux_output2 <- FluxCal(data = Flux_lgr, t = 3,
#'                         Time_keys = Time_Ta1,
#'                         Ta = Time_Ta1,
#'                         vol = 208, Area = 0.26,
#'                         output_d = FALSE) # don't create a output file
#' Flux_output2
#'
#' #### data from other sources
#' # get the directory of the example data
#' example_data2 <- system.file("extdata", "Flux_example_2_other.csv", package = "FluxCalR")
#' example_data2
#'
#' # load the data
#' Flux_other <- Load_other(example_data2,
#'                          Time_format = "mdy_hms",
#'                          Time = "Date_time",
#'                          CO2 = "CO2_PPM",
#'                          Ta = "Tem_C")
#'
#' # input the time cues as a file and calculate the fluxes over a 3-minute window
#' Time_Ta2 <- system.file("extdata", "Time & Ta_2.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Flux_output3 <- FluxCal(data = Flux_other, t = 3,
#'                         Time_keys = Time_Ta2,
#'                         vol = 208, Area = 0.26,
#'                         output_d = FALSE) # don't create a output file
#' Flux_output3
#'
#' @export
## Flux calculation function ---------------
FluxCal <- function(data,
                    cal = "CO2_CH4",
                    win,
                    vol,
                    area,
                    df_cue,
                    cue_type = "End",
                    other = NULL,
                    df_Ta = NULL,
                    ext = 1.5,
                    output = "Flux_output.csv",
                    digits = 3,
                    check_plot = TRUE,
                    ylim_CO2 = NULL,
                    ylim_CH4 = NULL

) {
  # check arguments
  cal <- match.arg(cal,c("CO2_CH4","CO2","CH4"))
  cue_type <- match.arg(cue_type,c("End","Start","Start_End"))
  # if volumn or base area of the chamber are not specified
  if (!is.numeric(vol) | !is.numeric(area)){
    stop("Error: both 'vol' and 'area' have to be specified!")
  }
  # define the pipe from the package "magrittr"
  `%>%` <- magrittr::`%>%`
  # calculate the sampling frequency based on the timestamps (unit: seconds)
  f <- round(as.numeric(difftime(data$Time[2],data$Time[1],units = "secs")))
  # constants
  R_index <- 0.08205783 # universal gas constant; unit: L*atm*K^-1*mol^-1
  win_f <- win*60/f # the number of rows for the defined window

  # add one column as row index and one as time (HH:MM:SS)
  data <- cbind(Row=row(data)[,1],data) %>%
    dplyr::mutate(time=paste(lubridate::hour(Time),
                             sprintf("%02d",lubridate::minute(Time)),
                             sprintf("%02d",floor(lubridate::second(Time))),sep = ":"))

  ### get the row index for the moving window in calculation ---------
  mov <- ext-1 # the extend of moving
  if (cue_type == "End"){ ### if end time is given
    In1 <- match(df_cue$End,data$time) # start moving
    In2 <- In1-mov*win_f # end of moving (backwards)
  } else {
    if (cue_type == "Start"){ ### if start time is given
      In1 <- match(df_cue$Start,data$time)+ext*win_f
      In2 <- In1-mov*win_f
    } else { ### if both start and end is given
      In1 <- match(df_cue$End,data$time)
      In2 <- match(df_cue$Start,data$time)+win_f
      # return an error if the window length is larger than the range between start and end
      if (any(as.numeric(difftime(df_cue$Start,df_cue$End,units = "secs"))<win*60)){
        stop(paste0("Error: check the differences between start and end time,
                    they must be larger than the window size (win) set for calculation!"))
      }
    }
  } # here get two time cues In1 (End) and In2 (Start)!!

  # return an error if the indices includes NAs
  if (anyNA(In1)|anyNA(In2)) {
    stop(paste0("Error: change the timestamp of measurement No.",
                which(is.na(In1)),which(is.na(In2)),
                " in the 'cue' 1 second forward..."))
  }

  # function to calculate R2, slopes and fluxes ----------
  CalFUN <- function(flux = "CO2") {
    dft <- data.frame(matrix(0,nrow(df_cue),9)) # for record the data
    names(dft) <- c("Num","Date","Start","End","Gas","Slope","R2","Ta","Index")
    ########## 1. calculate the max R2 and slopes of the regression winthin the window with an extended range
    for (a in 1:nrow(df_cue)){
      # the window is moving backwards from the end point
      for (b in In1[a]:In2[a]){
        if (flux == "CO2"){ # for CO2
          Slm <- try(summary(lm(data$X.CO2.d_ppm[(b-win_f):b]~data$Row[(b-win_f):b])),silent = TRUE)
        } else { # for CH4
          Slm <- try(summary(lm(data$X.CH4.d_ppm[(b-win_f):b]~data$Row[(b-win_f):b])),silent = TRUE)
        }
        # if no data is provided
        if (class(Slm)=="try-error"){
          stop(paste0("Error: make sure ",flux," data are provided and specified in the correct way (See the help)."))
        } else {
          dft[a,"Num"] <- a # the Number of measurements
        if (Slm$r.squared > dft[a,"R2"]) {
          dft[a,"Date"] <- paste0(lubridate::year(data$Time[1]),"-", # the date
                             lubridate::month(data$Time[1]),"-",
                             lubridate::day(data$Time[1]))
          dft[a,"Start"] <- strftime(data$Time[(b-win_f)],format="%H:%M:%S","UTC") # the start time of the slope
          dft[a,"End"] <- strftime(data$Time[b],format="%H:%M:%S","UTC") # the end time of the slope
          dft[a,"Gas"] <- flux # CO2 or CH4
          dft[a,"Slope"] <- try(round(Slm$coefficients[2]/f,digits = digits),silent = TRUE) # slope as against 1s
          dft[a,"R2"] <- try(round(Slm$r.squared,digits = 2),silent = TRUE) # R2
          dft[a,"Ta"] <- round(mean(data$AmbT_C[(b-win_f):b]),digits=2) # temperautre
          dft[a,"Index"] <- b # output the row index at the END of the slope for plotting the graphs
        }
        }
      } # end b loop
    } # end a loop, end of calculate the slopes

    ####### 2. determine which temperature will be used for flux calculation
    if (is.null(df_Ta)){ # if no Ta provided, use the ones measured by analyzer
      dft <- data.frame(dft,Tk=dft$Ta+273.2)
    } else { # if Ta is provided as a data frame, use the column "Ta"
      dft <- data.frame(dft,Tk=df_Ta$Ta+273.2) %>%
        dplyr::mutate(Ta=Tk-273.2) # replace the Ta with the provided values
    }

    ######## 3. calculate the flux
    dft <- dft %>%
      dplyr::mutate(Flux=try(round(((Slope*vol)/(R_index*Tk)/area),digits = digits),silent=TRUE)) # umol m-2 s-1

    # when other meta data need to be passed along from the Ta data frame
    if (!is.null(other)){
      dft <- try(data.frame(dft,df_cue[,c(other)]),silent = TRUE)
      if (class(dft=="try-error"))
        stop("Error: please check the 'other' argument is properly specified as column names (see the help)!")
    }

    ######### 4. plot the result if required
    if (check_plot == TRUE){ # if checking plot is needed, then make a graph
      # determine if the CO2 or CH4 column is used for ploting and ylim range
      if (flux=="CO2"){ # for CO2
        var <- "X.CO2.d_ppm"
        if (is.null(ylim_CO2)){
          ylim <- range(data$X.CO2.d_ppm)
        } else {
          ylim <- ylim_CO2
        }
      } else { # for CH4
        var <- "X.CH4.d_ppm"
        if (is.null(ylim_CH4)){
          ylim <- range(data$X.CH4.d_ppm)
        } else {
          ylim <- ylim_CH4
        }
      }
      # plot the data against the row index
      try(plot(data[,var],
               ylab=paste0(flux," readings in ppm"),
               xlab="Time",bty="n", xaxt="n",
               ylim=ylim),silent=TRUE)
      # plot the regression lines
      for (i in 1:nrow(dft)){
        Slm <- try(lm(data[(dft[i,"Index"]-win_f):dft[i,"Index"],var]~
                        data$Row[(dft[i,"Index"]-win_f):dft[i,"Index"]]),silent=TRUE)
        try(lines(data$Row[(dft[i,"Index"]-win_f):dft[i,"Index"]], Slm$fitted.values,
                  col="green", lwd=3),silent=TRUE)
        try(text(data[dft[i,"Index"]-win_f,"Row"],data[dft[i,"Index"]-win_f,var],
                 labels = paste(dft[i,"Num"]),
                 col="red",cex=1.2,pos = 3),silent=TRUE)
      }
      # add x-axis as time
      par(new=T)
      try(plot(data[,"Time"],data[,var],
               type = "n",axes = F, xlab = "", ylab = ""),silent=TRUE)
      # add time interval ticks
      c <- try(lubridate::pretty_dates(data$Time,n=10),silent=TRUE)
      try(axis.POSIXct(1, at= c,format = "%H:%M"),silent=TRUE)
    }
    return(dft)
  } # end of the function

  ###### calculate the flux using the function and, if required, output the file and plot the result ------------------
  if (check_plot == TRUE){ # if the checking plot is needed, create a window for plotting
    if (cal == "CO2_CH4"){ # both CO2 and CH4 are calculated, plot 2 graphs
      x11(width = 16,height = 12)
      par(mfrow=c(2,1),mar=c(2,1,2,1),xpd=NA,oma=c(4,4,1,1))
    } else { # only CO2 or CH4 is calculated, plot 1 graph
      x11(width = 16,height = 5)
      par(mar=c(0.5,1,0.5,1),xpd=NA,oma=c(4,4,1,1))
    }
  }
  # calculate and plot
  if (cal == "CO2_CH4"){ # both CO2 and CH4 are calculated
    df_CO2 <- CalFUN(flux = "CO2")
    df_CH4 <- CalFUN(flux = "CH4")
    dfoutput <- rbind(df_CO2,df_CH4) %>%
      dplyr::select(-Index,-Tk) # don't output the row index and Tk
  } else { # only CO2 or CH4 is calculated
    dfoutput <- CalFUN(flux = cal) %>%
      dplyr::select(-Index,-Tk) # don't output the row index and Tk
  }
  # check if the data frame needs to be output as a file
  if (assertthat::is.string(output)){
    write.csv(dfoutput,file = output,row.names = F)
  }

  return(dfoutput)
}
## function end here#####
