#' @title Calculate CO2 and CH4 gas fluxes
#'
#' @description Calculate CO2 and CH4 gas fluxes from the data loaded by the function "Load_LGR()" or "Load_other()". The function "FluxCal()" calculates CO2 and/or CH4 flux rates based on the time cues provided for each measurement (i.e., either start or end time). Two options are available to input the time cues:
#'
#' (1) (default) after executing the function, manually clicking on a pop-up graph with CO2 concentration time series to choose the END time, which could be identified as the local "peaks" or "valleys" in the time series; or
#'
#' (2) loading a file (.csv) into the argument "Time_keys" with times (HH:MM:SS) indicating start or end of each flux measurement. The header for the time must be either "Start" or "End". (see example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata).
#'
#' Based on the time cues and window width provided for the calculation, the function will automatically scan over data that cover 1.5x length of the window width and calculate the fluxes based on the best linear regression (i.e., largest R2). After the calculations are done, a graph with regression lines plotted on the CO2 and/or CH4 concentration time series will pop up for checkup purposes.
#'
#' @param data A dataframe generated by the function "Load_LGR" or "Load_other".
#' @param win A number indicates the window width for the flux calculation, unit: minutes.
#' @param vol A number indicates volume of the chamber; unit: dm^3 or L.
#' @param Area A number indicates base area of the chamber; unit: m^2.
#' @param spt An integer indicates the number of graphs to split the CO2 time series into for MANUALLY selecting the time cues. Cutting CO2 time series into several sections will aid the visualization and selection of the time cues when the data is too long. Default: 1. This argument is used only when no data is provided for the "Time_keys" argument.
#' @param Time_keys A string inidicates the directory and the name of the csv file that includes start or end time (HH:MM:SS) of each flux measurement.The header for the time must be either "Start" or "End". (see example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata).
#' Default: if no file is provided (NULL), a graph window will pop up to allow manually selecting the END time, which could be normally recognized as the local "peaks" or "valleys" of the time series.
#' @param Type_keys Either "start" or "end" (string) to indicate if start or end time will be used as the cues; default "start". This will only valid if a file name is provided for argument "Time_keys".
#' @param Ta A name (string) of a file contains a column "Ta" with the air temperature values (ideally, this is temperature measured inside of the chamber during the flux measurement; unit: degree C. See example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata). The length of Ta within the file must be the same as the number of flux measurements.
#' Default: if no file name is provided (NULL), the average ambient air temperature measured by the analyzer or Ta input from function "Load_other" will be used.
#' @param output_d A string includes output directory and file name (.csv) to export the calculated fluxes. Default: a file named "Flux_output.csv" with calculated fluxes will be created under the current work directory. FALSE, do not create the file.
#' @param ylim_CO2 A numeric vector of length 2, giving the y-axis scale range for CO2 concentration (ppm) for plotting purpose. If not specified (default), it will be set based on the CO2 range of the entire dataset.
#' @param ylim_CH4 A numeric vector of length 2, giving the y-axis scale range for CH4 concentration (ppm) for plotting purpose. If not specified (default), it will be set based on the CH4 range of the entire dataset.
#' @param digits An integer indicates the number of decimal digits to be used for the calculated flux and R2
#' @return A dataframe with calculated CO2 and CH4 fluxes ("FCO2" and "FCH4", respectively; unit: umol m^-2 s^-1) and other parameters (i.e. date, time, index, regression slopes, R2 and Ta). A copy of the dataframe will be saved as "Flux_output.csv" under the work directory or as what is provided in the argument "output_d". A graph with regression lines plotted on the CO2 and/or CH4 concentration time series will pop up for checkup purposes.
#'
#' @examples
#' #### data from LGR
#' # get the directory of the example LGR raw data
#' example_data1 <- system.file("extdata", "Flux_example_1_LGR.txt", package = "FluxCalR")
#' example_data1
#'
#' # load the data
#' Flux_lgr <- Load_LGR(example_data1)
#'
#' # manually select time cues and calculate the fluxes over a 3-minute window
#' Flux_output1 <- FluxCal(data = Flux_lgr, t = 3, vol = 208, Area = 0.26)
#' Flux_output1
#'
#' # input the time cues as a file and calculate the fluxes over a 3-minute window
#' Time_Ta1 <- system.file("extdata", "Time & Ta_1.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Flux_output2 <- FluxCal(data = Flux_lgr, t = 3,
#'                         Time_keys = Time_Ta1,
#'                         Ta = Time_Ta1,
#'                         vol = 208, Area = 0.26,
#'                         output_d = FALSE) # don't create a output file
#' Flux_output2
#'
#' #### data from other sources
#' # get the directory of the example data
#' example_data2 <- system.file("extdata", "Flux_example_2_other.csv", package = "FluxCalR")
#' example_data2
#'
#' # load the data
#' Flux_other <- Load_other(example_data2,
#'                          Time_format = "mdy_hms",
#'                          Time = "Date_time",
#'                          CO2 = "CO2_PPM",
#'                          Ta = "Tem_C")
#'
#' # input the time cues as a file and calculate the fluxes over a 3-minute window
#' Time_Ta2 <- system.file("extdata", "Time & Ta_2.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Flux_output3 <- FluxCal(data = Flux_other, t = 3,
#'                         Time_keys = Time_Ta2,
#'                         vol = 208, Area = 0.26,
#'                         output_d = FALSE) # don't create a output file
#' Flux_output3
#'
#' @export
## Flux calculation function ---------------
FluxCal <- function(data,
                    Cal = "CO2_CH4",
                    win,
                    vol,
                    Area,
                    Cue,
                    Cue_type = "End",
                    Ta = NULL,
                    Other,
                    ext = 1.5,
                    output_d = "Flux_output.csv",
                    digits = 3
) {
  # define the pipe from the package "magrittr"
  `%>%` <- magrittr::`%>%`
  # constants
  R_index = 0.08205783 # universal gas constant; unit: L*atm*K^-1*mol^-1
  # calculate the sampling frequency based on the timestamps (unit: seconds)
  f <- round(as.numeric(difftime(data$Time[2],data$Time[1],units = "secs")))

  # add one column as row index and one as time (HH:MM:SS)
  data <- cbind(Row=row(data)[,1],data) %>%
    dplyr::mutate(time=paste(lubridate::hour(Time),
                             sprintf("%02d",lubridate::minute(Time)),
                             sprintf("%02d",floor(lubridate::second(Time))),sep = ":"))

  ### get the row index for the moving window in calculation ------
  mov <- ext-1 # the extend of moving
  if (Cue_type == "End"){ ### if end time is given
    In1 <- match(Cue$End,data$time) # start moving
    In2 <- In1-mov*win*60/f # end of moving (backwards)
  } else {
    if (Cue_type == "Start"){ ### if start time is given
      In1 <- match(Cue$Start,data$time)+ext*win*60/f
      In2 <- In1-mov*win*60/f
    } else { ### if both start and end is given
      In1 <- match(Cue$End,data$time)
      In2 <- match(Cue$Start,data$time)+win*60/f
      # return an error if the window length is larger than the range between start and end
      if (any(as.numeric(difftime(Cue$Start,Cue$End,units = "secs"))<win*60)){
        stop(paste0("Check the differences between start and end time,
                    they must be larger than the window size (win) set for calculation!"))
      }
    }
  }

  # return an error if the indices includes NAs
  if (anyNA(In1)|anyNA(In2)) {
    stop(paste0("Change the timestamp of measurement No.",
                which(is.na(In1)),which(is.na(In2)),
                " in the 'Cue' 1 second forward..."))
  }

  ### calculate the max R2 of the regression before local max and min
  # R2 of CO2 fluxes
  Ta_CO2 <- vector() # for calculating average ambient temperature
  R2.CO2 <- data.frame(matrix(0,length(In),7))
  colnames(R2.CO2) <- c("R2_CO2","Index_CO2","Slope_CO2","p_CO2","Flux","Date","time_CO2")
  for (a in 1:length(In)){
    # the window is moving backwards from the end point
    for (b in In[a]:c(In[a]-0.5*t*60/f)){ # select 0.5 of the window width as testing for largest R2
      Slm <- try(summary(lm(data$X.CO2.d_ppm[(b-t*60/f):b]~data$Row[(b-t*60/f):b])),silent = TRUE)
      if (class(Slm)=="try-error"){ # if no CO2 data is provided
        R2.CO2[a,1:7] <- NA
        Ta_CO2[a] <- NA
      } else {
      if (Slm$r.squared > R2.CO2[a,1]) {
        R2.CO2[a,1] <- Slm$r.squared
        # output the time at the start of the slope
        R2.CO2[a,2] <- b
        R2.CO2[a,3] <- Slm$coefficients[2]/f
        R2.CO2[a,4] <- Slm$coefficients[8]
        R2.CO2[a,5] <- "CO2"
        R2.CO2[a,6] <- paste0(lubridate::year(data$Time[1]),"-",lubridate::month(data$Time[1]),"-",lubridate::day(data$Time[1]))
        R2.CO2[a,7] <- paste0(lubridate::hour(data$Time[(b-t*60/f)]),":",
                              lubridate::minute(data$Time[(b-t*60/f)]),":",
                              floor(lubridate::second(data$Time[(b-t*60/f)])))
        Ta_CO2[a] <- mean(data$AmbT_C[(b-t*60/f):b])
      }
      }
    }
  }

  # R2 of CH4 fluxes
  Ta_CH4 <- vector() # for calculating average ambient temperature
  R2.CH4 <- data.frame(matrix(0,length(In),7))
  colnames(R2.CH4) <- c("R2_CH4","Index_CH4","Slope_CH4","p_CH4","Flux","Date","time_CH4")
  for (a in 1:length(In)){
    for (b in In[a]:c(In[a]-0.5*t*60/f)){
      Slm <- try(summary(lm(data$X.CH4.d_ppm[(b-t*60/f):b]~data$Row[(b-t*60/f):b])),silent=TRUE)
      if (class(Slm)=="try-error"){ # if no CH4 data is provided
        R2.CH4[a,1:7] <- NA
        Ta_CH4[a] <- NA
      } else {
      if (Slm$r.squared > R2.CH4[a,1]) {
        R2.CH4[a,1] <- Slm$r.squared
        R2.CH4[a,2] <- b
        R2.CH4[a,3] <- Slm$coefficients[2]/f
        R2.CH4[a,4] <- Slm$coefficients[8]
        R2.CH4[a,5] <- "CH4"
        R2.CH4[a,6] <- paste0(lubridate::year(data$Time[1]),"-",lubridate::month(data$Time[1]),"-",lubridate::day(data$Time[1]))
        R2.CH4[a,7] <- paste0(lubridate::hour(data$Time[(b-t*60/f)]),":",
                              lubridate::minute(data$Time[(b-t*60/f)]),":",
                              floor(lubridate::second(data$Time[(b-t*60/f)])))
        Ta_CH4[a] <- mean(data$AmbT_C[(b-t*60/f):b])
      }
      }
    }
  }

  # determine which temperature will be used for flux calculation
  if (assertthat::is.string(Ta)){
    Tk_CO2 <- read.table(Ta,sep = ",",header = T)$Ta+273.2
    Tk_CH4 <- read.table(Ta,sep = ",",header = T)$Ta+273.2
  } else {
    Tk_CO2 <- Ta_CO2+273.2
    Tk_CH4 <- Ta_CH4+273.2
  }

  # create a index for each slope and calculate the flux
  # CO2
  R2.CO2 <- data.frame(R2.CO2,Id.slope=row(R2.CO2)[,1]) %>%
    dplyr::mutate(FCO2=ifelse(is.na(Slope_CO2),
                              NA,
                              round(((Slope_CO2*vol)/(R_index*Tk_CO2)/Area),digits = digits))) # umol CO2 m-2 s-1
  # CH4
  R2.CH4 <- data.frame(R2.CH4,Id.slope=row(R2.CH4)[,1]) %>%
    dplyr::mutate(FCH4=ifelse(is.na(Slope_CH4),
                              NA,
                              round(((Slope_CH4*vol)/(R_index*Tk_CH4)/Area),digits = digits))) # umol CH4 m-2 s-1
  # output of the calculations
  output <- cbind(R2.CO2[,c(6,2,7,9,1)],
                  Ta_CO2 = round(Tk_CO2-273.2,digits = 2),
                  R2.CH4[,c(2,7,9,1)],
                  Ta_CH4 = round(Tk_CH4-273.2,digits = 2))
  if (assertthat::is.string(output_d)){
    write.csv(output,file = output_d,row.names = F)
  }

  # Plot the regressions for visualization purpose
  x11(width = 16,height = 10)
  par(mfrow=c(2,1),mar=c(0.5,1,0.5,1),xpd=NA,oma=c(4,4,1,1))
  if (is.null(ylim_CO2)){
    suppressWarnings(try(with(data,plot(X.CO2.d_ppm,
                 ylab="CO2 readings in ppm", xlab = "",
                 bty="n", xaxt="n"#,ylim=c(380,460)
  )),silent=TRUE))
  } else {
    suppressWarnings(try(with(data,plot(X.CO2.d_ppm,
                   ylab="CO2 readings in ppm", xlab = "",
                   bty="n", xaxt="n",ylim=ylim_CO2
    )),silent=TRUE))
  }

  # CO2 regression lines
  for (i in 1:nrow(R2.CO2)){
    Slm <- try(lm(data$X.CO2.d_ppm[(R2.CO2[i,2]-t*60/f):R2.CO2[i,2]]~
                data$Row[(R2.CO2[i,2]-t*60/f):R2.CO2[i,2]]),silent=TRUE)
    try(lines(data$Row[(R2.CO2[i,2]-t*60/f):R2.CO2[i,2]], Slm$fitted.values,
          col="green", lwd=3),silent=TRUE)
    try(text(data$Row[In[i]-t*60/f],data$X.CO2.d_ppm[In[i]-t*60/f],
         labels = paste(R2.CO2[i,8]), # bquote(bold(atop(paste(R^2,"=",.(round(R2.CO2[i,1],2))),
         # paste("b=",.(round(R2.CO2[i,3],2)))))),
         col = "red",cex = 1.2,pos = 3),silent=TRUE)
  }


  # CH4 flux regression lines in seperate plot
  if (is.null(ylim_CH4)){
    suppressWarnings(try(with(data,plot(X.CH4.d_ppm, ylab="CH4 readings in ppm", xlab="Time",bty="n", xaxt="n"#, ylim=c(1.7,3)
    )),silent=TRUE))
  } else {
    suppressWarnings(try(with(data,plot(X.CH4.d_ppm, ylab="CH4 readings in ppm", xlab="Time",bty="n", xaxt="n", ylim=ylim_CH4
    )),silent=TRUE))
  }

  for (i in 1:nrow(R2.CH4)){
    Slm <- try(lm(data$X.CH4.d_ppm[(R2.CH4[i,2]-t*60/f):R2.CH4[i,2]]~
                data$Row[(R2.CH4[i,2]-t*60/f):R2.CH4[i,2]]),silent=TRUE)
    try(lines(data$Row[(R2.CH4[i,2]-t*60/f):R2.CH4[i,2]], Slm$fitted.values,
          col="green", lwd=3),silent=TRUE)
    try(text(data$Row[In[i]-t*60/f],data$X.CH4.d_ppm[In[i]-t*60/f],
         labels = paste(R2.CH4[i,8]), # bquote(bold(atop(paste(R^2,"=",.(round(R2.CH4[i,1],2))),
         # paste("b=",.(round(R2.CH4[i,3]*1000,2)),"e-3")))),
         col="red",cex=1.2,pos = 3),silent=TRUE)
  }
  par(new=T)
  suppressWarnings(try(with(data,plot(Time,X.CH4.d_ppm,type = "n",axes = F, xlab = "", ylab = "")),silent=TRUE))
  # add time interval ticks
  c <- try(lubridate::pretty_dates(data$Time,n=10),silent=TRUE)
  try(axis.POSIXct(1, at= c,format = "%H:%M"),silent=TRUE)

  return(output)
}
## function end here#####
