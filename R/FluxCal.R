#' @title Calculate CO2 and CH4 gas fluxes
#'
#' @description A function to calculate CO2 and CH4 gas fluxes from the data loaded by the function \code{\link{LoadLGR}}
#' or \code{\link{LoadOther}}.
#' It takes a time cue data frame (argument \code{df_cue}), either created by the function \code{\link{SelCue}} or prepared by the
#' user following the format of example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at
#'  https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata
#' to separate the measurements and then calculate the fluxes for all the measurements at once.
#' Note that the header for the time cue column must be either \strong{"Start"} or \strong{"End"}.
#' Based on the time cues and window width provided for the calculation, the function will automatically scan over data that cover
#'  1.5x (default) length of the window and calculate the fluxes based on the best linear regression (i.e., largest R2).
#'  After the calculations are done, a graph with regression lines plotted on the CO2 and/or CH4 concentration time series can be
#'  drawn for checkup purposes.
#'
#' @param data A dataframe generated by the function \code{\link{LoadLGR}} or \code{\link{LoadOther}}.
#' @param cal A string, either "CO2_CH4" (default),"CO2" or "CH4", indicates which gas flux it is calculated for.
#' @param win A number indicates the window width for the flux calculation, unit: minutes.
#' @param vol A number indicates volume of the chamber; unit: dm^3 or L.
#' @param area A number indicates base area of the chamber; unit: m^2.
#' @param df_cue A data frame that includes "Start" and/or "End" time (HH:MM:SS) of each measurement.
#' The header for the time must be either \strong{"Start"} or \strong{"End"}. This data frame can either be created by the
#' function \code{\link{SelCue}} or be prepared by the user
#' (see example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata).
#' @param cue_type A string, either "Start", "End" (default) or "Start_End", indicates if start, end or both time in the
#' data frame assigned to \code{df_cue} will be used as the cues . When "Start_End" is chosen, both "Start" and "End" columns
#' have to be present in the data frame for \code{df_cue} and the flux with the largest R2 within the range will be calculated
#' without considering the argument \code{ext}.
#' @param other A vector of strings indicates the names of other columns in the data frame for the \code{df_cue} argument
#' that need to be passed along to the final output data frame. Default: NULL.
#' @param df_Ta A data frame contains a column "Ta" with the air temperature values (ideally, this is temperature measured inside
#'  of the chamber during the flux measurement; unit: degree C. This can be the same data frame as in \code{df_cue}.
#'  See example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata).
#'  Note the row number of the data frame must be the same as the number of flux measurements.
#' Default: NULL, then the temperature used is either the average ambient air temperature measured by the LGR analyzer
#' (column "AmbT_C") or, if the data measured by other analyzers, Ta input from function \code{\link{LoadOther}}.
#' @param ext A number indicates a range of how many times of the window width (\code{win}) should the calculation scan through to
#' choose the regression with the largest R2. Default: 1.5. This argument is ignored when \code{df_cue} is "Start_End".
#' @param output A string includes output directory and file name (.csv) to export the calculated fluxes.
#' Default: a file named "Flux_output.csv" with calculated fluxes will be created under the current work directory.
#' FALSE, do not create a file.
#' @param digits An integer indicates the number of decimal digits to be used for the calculated fluxes and slopes.
#' @param check_plot A logic value indicates whether a checking plot should be drawn after the calculation. Default: TRUE.
#' @param ylim_CO2 A numeric vector of length 2, giving the y-axis scale range for CO2 concentration (ppm) for \code{check_plot}.
#' If not specified (default), it will be set based on the CO2 range of the entire dataset.
#' @param ylim_CH4 A numeric vector of length 2, giving the y-axis scale range for CH4 concentration (ppm) for \code{check_plot}.
#' If not specified (default), it will be set based on the CH4 range of the entire dataset.
#'
#' @return A data frame with 9 columns, including number of measurement ("Num"), date of measurement ("Date"), start and end time
#' for each flux calculation ("Start" and "End"), gas name ("Gas", either CO2 or CH4), slope ("Slope") and R2 ("R2") of the
#' regressions, air temperature used for calculation ("Ta") and the calculated fluxes ("Flux", unit: umol m-2 s-1).
#' As default, a copy of the data frame will be saved as "Flux_output.csv" under the work directory (or as what is provided in the
#' argument \code{output}) and a graph with regression lines plotted on the CO2 and/or CH4 concentration time series will pop up
#' for checkup purposes.
#'
#' @examples
#' \donttest{
#' library(FluxCalR)
#' #### data from LGR
#' # get the directory of the example LGR raw data
#' example_data1 <- system.file("extdata", "Flux_example_1_LGR.txt", package = "FluxCalR")
#' example_data1
#'
#' # load the data
#' Flux_lgr <- LoadLGR(file = example_data1,
#'                     time_format = "mdy_HMS")
#'
#' # manually select the end of each measurement as time cues
#' time_cue <- SelCue(Flux_lgr,flux = "CO2",cue = "End",save = FALSE)
#'
#' # calculate the fluxes over a 3-minute window using the manually selected cues
#' Flux_output1 <- FluxCal(data = Flux_lgr,
#'                         win = 3,
#'                         vol = 208, area = 0.26,
#'                         df_cue = time_cue,
#'                         cue_type = "End",
#'                         output = FALSE) # don't create a output file
#' Flux_output1
#'
#' # input the time cues from a prepared file and calculate the fluxes over a 3-minute window
#' Example_cue1 <- system.file("extdata", "Time & Ta_1.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Time_Ta1 <- read.csv(Example_cue1)
#' Flux_output2 <- FluxCal(data = Flux_lgr,
#'                         win = 3,
#'                         vol = 208, area = 0.26,
#'                         df_cue = Time_Ta1,
#'                         cue_type = "Start_End", # use both start and end time of each measurement as cues
#'                         other = c("Plot","Light_Dark"), # also pass other columns into the final output
#'                         df_Ta = Time_Ta1) # use separately measured air temperature for calculation
#' Flux_output2
#'
#' #### data from other sources
#' # get the directory of the example data
#' example_data2 <- system.file("extdata", "Flux_example_2_other.csv", package = "FluxCalR")
#' example_data2
#'
#' # load the data
#' Flux_other <- LoadOther(file = example_data2,
#'                         time = "Date_time",
#'                         time_format = "mdy_HMS",
#'                         CO2 = "CO2_PPM",
#'                         Ta = "Tem_C")
#'
#' # input the time cues from a prepared file and calculate the fluxes over a 3-minute window
#' Example_cue2 <- system.file("extdata", "Time & Ta_2.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Time_Ta2 <- read.csv(Example_cue2)
#' Flux_output3 <- FluxCal(data = Flux_other,
#'                         cal = "CO2", # only calculate CO2 flux
#'                         win = 3,
#'                         vol = 208, area = 0.26,
#'                         df_cue = Time_Ta2,
#'                         cue_type = "Start",
#'                         other = c("Plot","Light_Dark"),
#'                         output = FALSE) # don't create a output file
#' Flux_output3
#' }
#'
#' @export
## Flux calculation function ---------------
FluxCal <- function(data,
                    cal = "CO2_CH4",
                    win,
                    vol,
                    area,
                    df_cue,
                    cue_type = "End",
                    other = NULL,
                    df_Ta = NULL,
                    ext = 1.5,
                    output = "Flux_output.csv",
                    digits = 3,
                    check_plot = TRUE,
                    ylim_CO2 = NULL,
                    ylim_CH4 = NULL

) {
  # check arguments
  cal <- match.arg(cal,c("CO2_CH4","CO2","CH4"))
  cue_type <- match.arg(cue_type,c("End","Start","Start_End"))
  # # if volumn or base area of the chamber are not specified
  # if (!is.numeric(vol) | !is.numeric(area)){
  #   stop("Error: both 'vol' and 'area' have to be specified!")
  # }
  # ext has to be >=1
  if (ext < 1) {
    stop("Error: 'ext' argument can not be < 1 !")}
  # define the pipe from the package "magrittr"
  `%>%` <- magrittr::`%>%`
  # calculate the sampling frequency based on the timestamps (unit: seconds)
  f <- round(as.numeric(difftime(data$Time[2],data$Time[1],units = "secs")))
  # constants
  R_index <- 0.08205783 # universal gas constant; unit: L*atm*K^-1*mol^-1
  win_f <- win*60/f # the number of rows for the defined window

  # add one column as row index and one as time (HH:MM:SS)
  data <- cbind(Row=row(data)[,1],data) %>%
    dplyr::mutate(time=paste(lubridate::hour(Time),
                             sprintf("%02d",lubridate::minute(Time)),
                             sprintf("%02d",floor(lubridate::second(Time))),sep = ":"))

  ### get the row index for the moving window in calculation ---------
  mov <- ext-1 # the extend of moving
  if (cue_type == "End"){ ### if end time is given
    In1 <- match(df_cue$End,data$time) # start moving
    In2 <- In1-mov*win_f # end of moving (backwards)
    # return an error if the indices includes NAs
    if (anyNA(In1)) {
      stop(paste0("Error: change the 'End' timestamp of measurement No.",
                  which(is.na(In1)),which(is.na(In2)),
                  " in the 'df_cue' 1 second forward..."))
    }
  } else {
    if (cue_type == "Start"){ ### if start time is given
      In1 <- match(df_cue$Start,data$time)+ext*win_f
      In2 <- In1-mov*win_f
      # return an error if the indices includes NAs
      if (anyNA(In1)) {
        stop(paste0("Error: change the 'Start' timestamp of measurement No.",
                    which(is.na(In1)),which(is.na(In2)),
                    " in the 'df_cue' 1 second forward..."))
      }
    } else { ### if both start and end is given
      In1 <- match(df_cue$End,data$time)
      In2 <- match(df_cue$Start,data$time)+win_f
      # return an error if the indices includes NAs
      if (anyNA(In1)) {
        stop(paste0("Error: change the 'End' timestamp of measurement No.",
                    which(is.na(In1)),which(is.na(In2)),
                    " in the 'df_cue' 1 second forward..."))
      }
      if (anyNA(In2)) {
        stop(paste0("Error: change the 'Start' timestamp of measurement No.",
                    which(is.na(In1)),which(is.na(In2)),
                    " in the 'df_cue' 1 second forward..."))
      }
      # return an error if the window length is larger than the range between start and end
      if (any(In1-In2<0,na.rm = TRUE)){
        stop(paste0("Error: differences between start and end time must be larger than the window size (win)!"))
      }
    }
  } # here get two time cues In1 (End) and In2 (Start)!!

  # function to calculate R2, slopes and fluxes ----------
  CalFUN <- function(flux = "CO2") {
    dft <- data.frame(matrix(0,nrow(df_cue),9)) # for record the data
    names(dft) <- c("Num","Date","Start","End","Gas","Slope","R2","Ta","Index")
    ########## 1. calculate the max R2 and slopes of the regression winthin the window with an extended range
    for (a in 1:nrow(df_cue)){
      # the window is moving backwards from the end point
      for (b in In1[a]:In2[a]){
        if (flux == "CO2"){ # for CO2
          Slm <- try(summary(lm(data$X.CO2.d_ppm[(b-win_f):b]~data$Row[(b-win_f):b])),silent = TRUE)
        } else { # for CH4
          Slm <- try(summary(lm(data$X.CH4.d_ppm[(b-win_f):b]~data$Row[(b-win_f):b])),silent = TRUE)
        }
        # if no data is provided
        if (class(Slm)=="try-error" | is.na(Slm$r.squared)){
          stop(paste0("Error: make sure ",flux," data are provided and specified in the correct way (See the help)."))
        } else {
          dft[a,"Num"] <- a # the Number of measurements
          if (Slm$r.squared > dft[a,"R2"]) {
            dft[a,"Date"] <- paste0(lubridate::year(data$Time[1]),"-", # the date
                               lubridate::month(data$Time[1]),"-",
                               lubridate::day(data$Time[1]))
            dft[a,"Start"] <- strftime(data$Time[(b-win_f)],format="%H:%M:%S","UTC") # the start time of the slope
            dft[a,"End"] <- strftime(data$Time[b],format="%H:%M:%S","UTC") # the end time of the slope
            dft[a,"Gas"] <- flux # CO2 or CH4
            dft[a,"Slope"] <- try(round(Slm$coefficients[2]/f,digits = digits),silent = TRUE) # slope as against 1s
            dft[a,"R2"] <- try(round(Slm$r.squared,digits = 2),silent = TRUE) # R2
            dft[a,"Ta"] <- round(mean(data$AmbT_C[(b-win_f):b]),digits=2) # temperautre
            dft[a,"Index"] <- b # output the row index at the END of the slope for plotting the graphs
          } # end of if for R2
        }
      } # end b loop
    } # end a loop, end of calculate the slopes

    ####### 2. determine which temperature will be used for flux calculation
    if (is.null(df_Ta)){ # if no Ta provided, use the ones measured by analyzer
      dft <- data.frame(dft,Tk=dft$Ta+273.2)
    } else { # if Ta is provided as a data frame, use the column "Ta"
      dft <- data.frame(dft,Tk=df_Ta$Ta+273.2) %>%
        dplyr::mutate(Ta=Tk-273.2) # replace the Ta with the provided values
    }

    ######## 3. calculate the flux
    dft <- dft %>%
      dplyr::mutate(Flux=try(round(((Slope*vol)/(R_index*Tk)/area),digits = digits),silent=TRUE)) # umol m-2 s-1

    # when other meta data need to be passed along from the df_cue data frame
    if (!is.null(other)){
      dft <- try(data.frame(dft,df_cue[,c(other)]),silent = TRUE)
      if (class(dft)=="try-error")
        stop("Error: please check the 'other' argument is properly specified as column names (see the help)!")
    }

    ######### 4. plot the result if required
    if (check_plot == TRUE){ # if checking plot is needed, then make a graph
      # determine if the CO2 or CH4 column is used for ploting and ylim range
      if (flux=="CO2"){ # for CO2
        var <- "X.CO2.d_ppm"
        if (is.null(ylim_CO2)){
          ylim <- range(data$X.CO2.d_ppm)
        } else {
          ylim <- ylim_CO2
        }
      } else { # for CH4
        var <- "X.CH4.d_ppm"
        if (is.null(ylim_CH4)){
          ylim <- range(data$X.CH4.d_ppm)
        } else {
          ylim <- ylim_CH4
        }
      }
      # plot the data against the row index
      try(plot(data[,var],
               ylab=paste0(flux," readings in ppm"),
               xlab="Time",bty="n", xaxt="n",
               ylim=ylim),silent=TRUE)
      # plot the regression lines
      for (i in 1:nrow(dft)){
        Slm <- try(lm(data[(dft[i,"Index"]-win_f):dft[i,"Index"],var]~
                        data$Row[(dft[i,"Index"]-win_f):dft[i,"Index"]]),silent=TRUE)
        try(lines(data$Row[(dft[i,"Index"]-win_f):dft[i,"Index"]], Slm$fitted.values,
                  col="green", lwd=3),silent=TRUE)
        try(text(data[dft[i,"Index"]-win_f,"Row"],data[dft[i,"Index"]-win_f,var],
                 labels = paste(dft[i,"Num"]),
                 col="red",cex=1.2,pos = 3),silent=TRUE)
      }
      # add x-axis as time
      par(new=T)
      try(plot(data[,"Time"],data[,var],
               type = "n",axes = F, xlab = "", ylab = ""),silent=TRUE)
      # add time interval ticks
      c <- try(lubridate::pretty_dates(data$Time,n=10),silent=TRUE)
      try(axis.POSIXct(1, at= c,format = "%H:%M"),silent=TRUE)
    }
    return(dft)
  } # end of the function

  ###### calculate the flux using the function and, if required, output the file and plot the result ------------------
  if (check_plot == TRUE){ # if the checking plot is needed, create a window for plotting
    if (cal == "CO2_CH4"){ # both CO2 and CH4 are calculated, plot 2 graphs
      x11(width = 16,height = 12)
      par(mfrow=c(2,1),mar=c(2,1,2,1),xpd=NA,oma=c(4,4,1,1))
    } else { # only CO2 or CH4 is calculated, plot 1 graph
      x11(width = 16,height = 5)
      par(mar=c(0.5,1,0.5,1),xpd=NA,oma=c(4,4,1,1))
    }
  }
  # calculate and plot
  if (cal == "CO2_CH4"){ # both CO2 and CH4 are calculated
    df_CO2 <- CalFUN(flux = "CO2")
    df_CH4 <- CalFUN(flux = "CH4")
    dfoutput <- rbind(df_CO2,df_CH4) %>%
      dplyr::select(-Index,-Tk) # don't output the row index and Tk
  } else { # only CO2 or CH4 is calculated
    dfoutput <- CalFUN(flux = cal) %>%
      dplyr::select(-Index,-Tk) # don't output the row index and Tk
  }
  # check if the data frame needs to be output as a file
  if (assertthat::is.string(output)){
    write.csv(dfoutput,file = output,row.names = F)
  }

  return(dfoutput)
}
## function end here#####
