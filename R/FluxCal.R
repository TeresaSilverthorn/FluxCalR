#' @title Calculate CO2 and CH4 gas fluxes
#'
#' @description Calculate CO2 and CH4 gas fluxes from the data loaded by the function "Load_LGR()" or "Load_other()". The function "FluxCal()" calculates CO2 and/or CH4 flux rates based on the time cues provided for each measurement (i.e., either start or end time). Two options are available to input the time cues:
#'
#' (1) (default) after executing the function, manually clicking on a pop-up graph with CO2 concentration time series to choose the END time, which could be identified as the local "peaks" or "valleys" in the time series; or
#'
#' (2) loading a file (.csv) into the argument "Time_keys" with times (HH:MM:SS) indicating start or end of each flux measurement. The header for the time must be either "Start" or "End". (see example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata).
#'
#' Based on the time cues and window width provided for the calculation, the function will automatically scan over data that cover 1.5x length of the window width and calculate the fluxes based on the best linear regression (i.e., largest R2). After the calculations are done, a graph with regression lines plotted on the CO2 and/or CH4 concentration time series will pop up for checkup purposes.
#'
#' @param data A dataframe generated by the function "Load_LGR" or "Load_other".
#' @param win A number indicates the window width for the flux calculation, unit: minutes.
#' @param vol A number indicates volume of the chamber; unit: dm^3 or L.
#' @param Area A number indicates base area of the chamber; unit: m^2.
#' @param spt An integer indicates the number of graphs to split the CO2 time series into for MANUALLY selecting the time cues. Cutting CO2 time series into several sections will aid the visualization and selection of the time cues when the data is too long. Default: 1. This argument is used only when no data is provided for the "Time_keys" argument.
#' @param Time_keys A string inidicates the directory and the name of the csv file that includes start or end time (HH:MM:SS) of each flux measurement.The header for the time must be either "Start" or "End". (see example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata).
#' Default: if no file is provided (NULL), a graph window will pop up to allow manually selecting the END time, which could be normally recognized as the local "peaks" or "valleys" of the time series.
#' @param Type_keys Either "start" or "end" (string) to indicate if start or end time will be used as the cues; default "start". This will only valid if a file name is provided for argument "Time_keys".
#' @param Ta A name (string) of a file contains a column "Ta" with the air temperature values (ideally, this is temperature measured inside of the chamber during the flux measurement; unit: degree C. See example files "Time & Ta_1.csv" and "Time & Ta_2.csv" at https://github.com/junbinzhao/FluxCalR/tree/master/inst/extdata). The length of Ta within the file must be the same as the number of flux measurements.
#' Default: if no file name is provided (NULL), the average ambient air temperature measured by the LGR analyzer or, if the data measured with other analyzers, Ta input from function "Load_other" will be used.
#' @param output_d A string includes output directory and file name (.csv) to export the calculated fluxes. Default: a file named "Flux_output.csv" with calculated fluxes will be created under the current work directory. FALSE, do not create the file.
#' @param ylim_CO2 A numeric vector of length 2, giving the y-axis scale range for CO2 concentration (ppm) for plotting purpose. If not specified (default), it will be set based on the CO2 range of the entire dataset.
#' @param ylim_CH4 A numeric vector of length 2, giving the y-axis scale range for CH4 concentration (ppm) for plotting purpose. If not specified (default), it will be set based on the CH4 range of the entire dataset.
#' @param digits An integer indicates the number of decimal digits to be used for the calculated flux and R2
#' @return A dataframe with calculated CO2 and CH4 fluxes ("FCO2" and "FCH4", respectively; unit: umol m^-2 s^-1) and other parameters (i.e. date, time, index, regression slopes, R2 and Ta). A copy of the dataframe will be saved as "Flux_output.csv" under the work directory or as what is provided in the argument "output_d". A graph with regression lines plotted on the CO2 and/or CH4 concentration time series will pop up for checkup purposes.
#'
#' @examples
#' #### data from LGR
#' # get the directory of the example LGR raw data
#' example_data1 <- system.file("extdata", "Flux_example_1_LGR.txt", package = "FluxCalR")
#' example_data1
#'
#' # load the data
#' Flux_lgr <- Load_LGR(example_data1)
#'
#' # manually select time cues and calculate the fluxes over a 3-minute window
#' Flux_output1 <- FluxCal(data = Flux_lgr, t = 3, vol = 208, Area = 0.26)
#' Flux_output1
#'
#' # input the time cues as a file and calculate the fluxes over a 3-minute window
#' Time_Ta1 <- system.file("extdata", "Time & Ta_1.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Flux_output2 <- FluxCal(data = Flux_lgr, t = 3,
#'                         Time_keys = Time_Ta1,
#'                         Ta = Time_Ta1,
#'                         vol = 208, Area = 0.26,
#'                         output_d = FALSE) # don't create a output file
#' Flux_output2
#'
#' #### data from other sources
#' # get the directory of the example data
#' example_data2 <- system.file("extdata", "Flux_example_2_other.csv", package = "FluxCalR")
#' example_data2
#'
#' # load the data
#' Flux_other <- Load_other(example_data2,
#'                          Time_format = "mdy_hms",
#'                          Time = "Date_time",
#'                          CO2 = "CO2_PPM",
#'                          Ta = "Tem_C")
#'
#' # input the time cues as a file and calculate the fluxes over a 3-minute window
#' Time_Ta2 <- system.file("extdata", "Time & Ta_2.csv", package = "FluxCalR") # directory of the file with time cues and Ta
#' Flux_output3 <- FluxCal(data = Flux_other, t = 3,
#'                         Time_keys = Time_Ta2,
#'                         vol = 208, Area = 0.26,
#'                         output_d = FALSE) # don't create a output file
#' Flux_output3
#'
#' @export
## Flux calculation function ---------------
FluxCal <- function(data,
                    Cal = "CO2_CH4",
                    win,
                    vol,
                    Area,
                    Cue,
                    Cue_type = "End",
                    df_Ta = NULL,
                    Other = NULL,
                    ext = 1.5,
                    output = "Flux_output.csv",
                    digits = 3,
                    check_plot = TRUE,
                    ylim_CO2 = NULL,
                    ylim_CH4 = NULL

) {
  # define the pipe from the package "magrittr"
  `%>%` <- magrittr::`%>%`
  # constants
  R_index = 0.08205783 # universal gas constant; unit: L*atm*K^-1*mol^-1
  # calculate the sampling frequency based on the timestamps (unit: seconds)
  f <- round(as.numeric(difftime(data$Time[2],data$Time[1],units = "secs")))

  # add one column as row index and one as time (HH:MM:SS)
  data <- cbind(Row=row(data)[,1],data) %>%
    dplyr::mutate(time=paste(lubridate::hour(Time),
                             sprintf("%02d",lubridate::minute(Time)),
                             sprintf("%02d",floor(lubridate::second(Time))),sep = ":"))

  ### get the row index for the moving window in calculation ---------
  mov <- ext-1 # the extend of moving
  if (Cue_type == "End"){ ### if end time is given
    In1 <- match(Cue$End,data$time) # start moving
    In2 <- In1-mov*win*60/f # end of moving (backwards)
  } else {
    if (Cue_type == "Start"){ ### if start time is given
      In1 <- match(Cue$Start,data$time)+ext*win*60/f
      In2 <- In1-mov*win*60/f
    } else { ### if both start and end is given
      In1 <- match(Cue$End,data$time)
      In2 <- match(Cue$Start,data$time)+win*60/f
      # return an error if the window length is larger than the range between start and end
      if (any(as.numeric(difftime(Cue$Start,Cue$End,units = "secs"))<win*60)){
        stop(paste0("Error: check the differences between start and end time,
                    they must be larger than the window size (win) set for calculation!"))
      }
    }
  } # here get two time cues In1 (End) and In2 (Start)!!

  # return an error if the indices includes NAs
  if (anyNA(In1)|anyNA(In2)) {
    stop(paste0("Error: change the timestamp of measurement No.",
                which(is.na(In1)),which(is.na(In2)),
                " in the 'Cue' 1 second forward..."))
  }

  # function to calculate R2, slopes and fluxes ----------
  CalFUN <- function(flux = "CO2") {
    dft <- data.frame(matrix(0,nrow(Cue),9)) # for record the data
    names(dft) <- c("Num","Date","Start","End","Gas","Slope","R2","Ta","Index")
    ########## 1. calculate the max R2 and slopes of the regression winthin the window with an extended range
    for (a in 1:nrow(Cue)){
      # the window is moving backwards from the end point
      for (b in In1[a]:In2[a]){
        if (flux == "CO2"){ # for CO2
          Slm <- try(summary(lm(data$X.CO2.d_ppm[(b-win*60/f):b]~data$Row[(b-win*60/f):b])),silent = TRUE)
        } else { # for CH4
          Slm <- try(summary(lm(data$X.CH4.d_ppm[(b-win*60/f):b]~data$Row[(b-win*60/f):b])),silent = TRUE)
        }
        # if no data is provided
        if (class(Slm)=="try-error"){
          stop(paste0("Error: make sure ",flux," data are provided and specified in the correct way (See the help)."))
        } else {
          dft[a,1] <- a # the Number of measurements
        if (Slm$r.squared > dft[a,"R2"]) {
          dft[a,2] <- paste0(lubridate::year(data$Time[1]),"-", # the date
                             lubridate::month(data$Time[1]),"-",
                             lubridate::day(data$Time[1]))
          dft[a,3] <- strftime(data$Time[(b-win*60/f)],format="%H:%M:%S","UTC") # the start time of the slope
          dft[a,4] <- strftime(data$Time[b],format="%H:%M:%S","UTC") # the end time of the slope
          dft[a,5] <- flux # CO2 or CH4
          dft[a,6] <- try(round(Slm$coefficients[2]/f,digits = digits),silent = TRUE) # slope as against 1s
          dft[a,7] <- try(round(Slm$r.squared,digits = 2),silent = TRUE) # R2
          dft[a,8] <- round(mean(data$AmbT_C[(b-win*60/f):b]),digits=2) # temperautre
          dft[a,9] <- b # output the row index at the END of the slope for plotting the graphs
          # dft[a,4] <- Slm$coefficients[8] # p value
        }
        }
      } # end b loop
    } # end a loop, end of calculate the slopes

    ####### 2. determine which temperature will be used for flux calculation
    if (is.null(df_Ta)){ # if no Ta provided, use the ones measured by analyzer
      dft <- data.frame(dft,Tk=dft$Ta+273.2)
    } else { # if Ta is provided as a data frame, use the column "Ta"
      dft <- data.frame(dft,Tk=df_Ta$Ta+273.2) %>%
        dplyr::mutate(Ta=Tk-273.2) # replace the Ta with the provided values
    }

    ######## 3. calculate the flux
    dft <- dft %>%
      dplyr::mutate(Flux=try(round(((Slope*vol)/(R_index*Tk)/Area),digits = digits),silent=TRUE)) # umol m-2 s-1

    # when other meta data need to be passed along from the Ta data frame
    if (!is.null(Other)){
      dft <- try(data.frame(dft,df_Ta[,c(Other)]),silent = TRUE)
      if (class(dft=="try-error"))
        stop("Error: please check the 'Other' argument is properly specified as column names (see the help)!")
    }

    ######### 4. plot the result if required
    if (check_plot == TRUE){ # if checking plot is needed, then make a graph
      # determine if the CO2 or CH4 column is used for ploting and ylim range
      if (flux=="CO2"){ # for CO2
        var <- "X.CO2.d_ppm"
        if (is.null(ylim_CO2)){
          ylim <- range(data$X.CO2.d_ppm)
        } else {
          ylim <- ylim_CO2
        }
      } else { # for CH4
        var <- "X.CH4.d_ppm"
        if (is.null(ylim_CH4)){
          ylim <- range(data$X.CH4.d_ppm)
        } else {
          ylim <- ylim_CH4
        }
      }
      # plot the data against the row index
      try(plot(data[,var],
               ylab=paste0(flux," readings in ppm"),
               xlab="Time",bty="n", xaxt="n",
               ylim=ylim),silent=TRUE)
      # plot the regression lines
      for (i in 1:nrow(dft)){
        Slm <- try(lm(data[(dft[i,"Index"]-win*60/f):dft[i,"Index"],var]~
                        data$Row[(dft[i,"Index"]-win*60/f):dft[i,"Index"]]),silent=TRUE)
        try(lines(data$Row[(dft[i,"Index"]-win*60/f):dft[i,"Index"]], Slm$fitted.values,
                  col="green", lwd=3),silent=TRUE)
        try(text(data[dft[i,"Index"]-win*60/f,"Row"],data[dft[i,"Index"]-win*60/f,var],
                 labels = paste(dft[i,"Num"]),
                 col="red",cex=1.2,pos = 3),silent=TRUE)
      }
      # add x-axis as time
      par(new=T)
      try(plot(data[,"Time"],data[,var],
               type = "n",axes = F, xlab = "", ylab = ""),silent=TRUE)
      # add time interval ticks
      c <- try(lubridate::pretty_dates(data$Time,n=10),silent=TRUE)
      try(axis.POSIXct(1, at= c,format = "%H:%M"),silent=TRUE)
    }
    return(dft)
  } # end of the function

  ###### calculate the flux using the function and, if required, output the file and plot the result ------------------
  if (check_plot == TRUE){ # if the checking plot is needed, create a window for plotting
    if (Cal == "CO2_CH4"){ # both CO2 and CH4 are calculated, plot 2 graphs
      x11(width = 16,height = 12)
      par(mfrow=c(2,1),mar=c(2,1,2,1),xpd=NA,oma=c(4,4,1,1))
    } else { # only CO2 or CH4 is calculated, plot 1 graph
      x11(width = 16,height = 5)
      par(mar=c(0.5,1,0.5,1),xpd=NA,oma=c(4,4,1,1))
    }
  }
  # calculate and plot
  if (Cal == "CO2_CH4"){ # both CO2 and CH4 are calculated
    df_CO2 <- CalFUN(flux = "CO2")
    df_CH4 <- CalFUN(flux = "CH4")
    dfoutput <- rbind(df_CO2,df_CH4) %>%
      dplyr::select(-Index,-Tk) # don't output the row index and Tk
  } else { # only CO2 or CH4 is calculated
    dfoutput <- CalFUN(flux = Cal) %>%
      dplyr::select(-Index,-Tk) # don't output the row index and Tk
  }
  # check if the data frame needs to be output as a file
  if (assertthat::is.string(output)){
    write.csv(dfoutput,file = output,row.names = F)
  }

  return(dfoutput)
}
## function end here#####
